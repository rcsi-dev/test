/* ===============================================================
 * secure_uart.c  –  Реализация легковесного протокола
 * ===============================================================
 * Имплементирует небольшой слой поверх UART, который способен:
 * опционально шифровать трафик (SPECK 64/96 CTR-режим);
 * выполнять аппаратный CRC-32 - защита от помех
 * и криптографический MAC (SipHash 2-4) - защита от подмены.
 *
 *  API в header-файле.
 * ===============================================================*/

#include "main.h"
#include "secure_uart.h"
#include "stm32f4xx_hal.h"
#include <string.h>

/* Include AES implementation if needed */
#if SECURE_UART_CIPHER == CIPHER_AES
#include "secure_aes.h"
#endif

/* ------------------
 * Опции при сборке
 * ----------------*/
#define SECURE_UART_CNT_WINDOW      8U

/* -----------
 * Константы
 * ---------*/
#define SYNC_HIGH  0x55U
#define SYNC_LOW   0xAAU
#define SYNC_LEN   2U
#define LEN_LEN    1U
#define CNT_LEN    1U
#define CRC_LEN    4U
#define MAC_LEN    8U

/* ------------------------
 * Демонстрационные ключи
 * ----------------------*/
static const uint32_t siphash_key[4] = {
		0x01234567, 0x89ABCDEF, 0x0BADF00D, 0xDEADBEEF };

#if SECURE_UART_CIPHER == CIPHER_SPECK
static const uint32_t speck_k96[3] = {
		0xA56BABCD, 0x00010203, 0xF0E1D2C3 };
#elif SECURE_UART_CIPHER == CIPHER_AES
/* AES key is 128 bits (16 bytes) */
static const uint8_t aes_key[16] = {
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xF0, 0xE1, 0xD2, 0xC3, 0xA5, 0x6B, 0xAB, 0xCD };
static aes_ctx_t aes_context;
#endif

/* Счетчики от реплей-атак */
static uint8_t cnt_tx      = 0;
static uint8_t cnt_rx_last = 0xFF;

extern CRC_HandleTypeDef hcrc;

/* ==================================================================
 * SPECK-64/96 – блочный шифр из 26 раундов (блок 64 bit, ключ 96 bit)
 * ==================================================================*/
#if SECURE_UART_CIPHER == CIPHER_SPECK
#define ROR32(x,r)  __ror(x, r)
#define ROL32(x,r)  ( ((x) << (r)) | ((x) >> (32U-(r))) )

static void speck64_key_schedule(const uint32_t k[3], uint32_t rk[26])
{
	uint32_t x = k[2];
	uint32_t y = k[1];
	rk[0] = k[0];
	for(uint8_t i = 0; i < 25; ++i){           /* produce rk[1]..rk[25] */
		x = (ROR32(x,8) + y) ^ i;
		y =  ROR32(y,3) ^ x;
		rk[i+1] = x;
	}
}

static void speck64_encrypt(const uint32_t rk[26], uint32_t b[2])
{
	uint32_t x = b[1], y = b[0];
	for(uint8_t i = 0; i < 26; ++i){
		x = (ROR32(x,8) + y) ^ rk[i];
		y =  ROR32(y,3) ^ x;
	}
	b[1] = x;  b[0] = y;
}

/* SPECK-CTR helper */
static void speck64_ctr_crypt(uint32_t rk[26],
		uint8_t *buf, uint8_t len,
		uint32_t iv_low)
{
	uint64_t ctr = iv_low;            /* 64-битный счётчик */
	for (uint8_t off=0; off < len; off += 8, ++ctr) {
		uint32_t blk[2] = { (uint32_t)ctr, (uint32_t)(ctr>>32) };
		speck64_encrypt(rk, blk);     /* keystream = E_K(ctr) */
		for (uint8_t i=0; i<8 && (off+i)<len; ++i)
			buf[off+i] ^= ((uint8_t*)blk)[i];
	}
}

#endif /* CIPHER_SPECK */

/* Initialize AES context if using AES */
#if SECURE_UART_CIPHER == CIPHER_AES
static void aes_init(void) {
    aes_key_setup(aes_key, &aes_context);
}
#endif

static uint32_t crc32(const uint8_t *buf, uint16_t len)
{
    // 1) сколько 32-битных слов нам нужно:
    uint16_t words = (len + 3) / 4;                  // ceil(len/4)

    // 2) временный массив на стеке (максимум: (256+3)/4 = 65, OK):
    uint32_t tmp[65];                                // 65*4 = 260 B

    // 3) обнуляем весь буфер и копируем байты:
    for(uint16_t i=0; i<words; ++i) tmp[i] = 0;
    memcpy(tmp, buf, len);

    // 4) считаем аппаратным CRC над этими словами:
    uint32_t crc = HAL_CRC_Calculate(&hcrc, tmp, words);
    return crc;
}

/* ==============================================================================
 * SipHash-128/2-4 → 64-bit tag  (реализация взята из общедоступного источника)
 * https://github.com/veorq/SipHash
 * ============================================================================*/
#define U8TO64_LE(p) ( ((uint64_t)(p)[0])       | ((uint64_t)(p)[1]<<8)  | \
		((uint64_t)(p)[2]<<16) | ((uint64_t)(p)[3]<<24) | \
		((uint64_t)(p)[4]<<32) | ((uint64_t)(p)[5]<<40) | \
		((uint64_t)(p)[6]<<48) | ((uint64_t)(p)[7]<<56) )
#define ROTL64(x,b)  ( ((x) << (b)) | ((x) >> (64-(b))) )

static uint64_t siphash24(const uint8_t *in, size_t inlen)
{
	uint64_t k0 = ((const uint64_t*)siphash_key)[0];
	uint64_t k1 = ((const uint64_t*)siphash_key)[1];
	uint64_t v0 = 0x736f6d6570736575ULL ^ k0;
	uint64_t v1 = 0x646f72616e646f6dULL ^ k1;
	uint64_t v2 = 0x6c7967656e657261ULL ^ k0;
	uint64_t v3 = 0x7465646279746573ULL ^ k1;

	const uint8_t *end = in + inlen - (inlen & 7);
	while(in != end){
		uint64_t m = U8TO64_LE(in); in += 8;
		v3 ^= m;
		for(uint8_t r=0;r<2;r++){
			v0+=v1; v1=ROTL64(v1,13); v1^=v0; v0=ROTL64(v0,32);
			v2+=v3; v3=ROTL64(v3,16); v3^=v2;
			v0+=v3; v3=ROTL64(v3,21); v3^=v0;
			v2+=v1; v1=ROTL64(v1,17); v1^=v2; v2=ROTL64(v2,32);
		}
		v0 ^= m;
	}
	uint64_t b = ((uint64_t)inlen) << 56;
	switch(inlen & 7){
	case 7: b |= ((uint64_t)in[6]) << 48;
	case 6: b |= ((uint64_t)in[5]) << 40;
	case 5: b |= ((uint64_t)in[4]) << 32;
	case 4: b |= ((uint64_t)in[3]) << 24;
	case 3: b |= ((uint64_t)in[2]) << 16;
	case 2: b |= ((uint64_t)in[1]) <<  8;
	case 1: b |= ((uint64_t)in[0]);        break;
	default: break;
	}
	v3 ^= b;
	for(uint8_t r=0;r<2;r++){
		v0+=v1; v1=ROTL64(v1,13); v1^=v0; v0=ROTL64(v0,32);
		v2+=v3; v3=ROTL64(v3,16); v3^=v2;
		v0+=v3; v3=ROTL64(v3,21); v3^=v0;
		v2+=v1; v1=ROTL64(v1,17); v1^=v2; v2=ROTL64(v2,32);
	}
	v0 ^= b;
	v2 ^= 0xff;
	for(uint8_t r=0;r<4;r++){
		v0+=v1; v1=ROTL64(v1,13); v1^=v0; v0=ROTL64(v0,32);
		v2+=v3; v3=ROTL64(v3,16); v3^=v2;
		v0+=v3; v3=ROTL64(v3,21); v3^=v0;
		v2+=v1; v1=ROTL64(v1,17); v1^=v2; v2=ROTL64(v2,32);
	}
	return v0 ^ v1 ^ v2 ^ v3;
}

/* ================================
 *  secure_uart_build  –  TX side
 * ==============================*/
secure_uart_status_t
secure_uart_build(const uint8_t *payload, uint8_t plen,
		uint8_t *frame,  uint8_t *framelen)
{
	if(plen > SECURE_UART_MAX_PAYLOAD) return SECURE_UART_LEN_ERR;

	uint8_t *p = frame;
	*p++ = SYNC_HIGH;                 /* SYNC */
	*p++ = SYNC_LOW;
	*p++ = plen + CNT_LEN + CRC_LEN + MAC_LEN;   /* LEN */
	*p++ = cnt_tx++;                                 /* CNT */

#if SECURE_UART_USE_ENCRYPTION
#if SECURE_UART_CIPHER == CIPHER_SPECK
	uint32_t rk[26];
	speck64_key_schedule(speck_k96, rk);

	uint8_t enc[SECURE_UART_MAX_PAYLOAD];
	memcpy(enc, payload, plen);
	speck64_ctr_crypt(rk, enc, plen, frame[3]);   /* iv = CNT */
#elif SECURE_UART_CIPHER == CIPHER_AES
    /* Initialize AES context if not done yet */
    static uint8_t aes_initialized = 0;
    if (!aes_initialized) {
        aes_init();
        aes_initialized = 1;
    }

    uint8_t enc[SECURE_UART_MAX_PAYLOAD];
    memcpy(enc, payload, plen);
    aes_ctr_crypt(&aes_context, enc, plen, frame[3]);   /* iv = CNT */
#endif

	/* enc уже зашифрован – копируем в кадр */
	memcpy(p, enc, plen);
#else
	memcpy(p, payload, plen);
#endif
	p += plen;

	/* CRC32 over LEN..CRC‑1 (i.e., CNT+PAYLOAD) */
	uint16_t crc_region = LEN_LEN + CNT_LEN + plen;     // = 1 +1 + payload-length
	uint32_t crc = crc32(frame + SYNC_LEN, crc_region);
	memcpy(p, &crc, CRC_LEN);
	p += CRC_LEN;

	/* MAC over LEN..CRC */
	uint64_t mac = siphash24(frame+SYNC_LEN+LEN_LEN,
			plen + CNT_LEN + CRC_LEN);
	memcpy(p, &mac, MAC_LEN); p += MAC_LEN;

	*framelen = (uint8_t)(p - frame);
	return SECURE_UART_OK;
}

/* ================================
 *  secure_uart_parse  –  RX side
 * ==============================*/
secure_uart_status_t
secure_uart_parse(uint8_t *frame, uint16_t size,
		uint8_t *out,   uint8_t *out_len)
{
	if(size < (SYNC_LEN+LEN_LEN+CNT_LEN+CRC_LEN+MAC_LEN))
		return SECURE_UART_LEN_ERR;
	if(frame[0]!=SYNC_HIGH || frame[1]!=SYNC_LOW)
		return SECURE_UART_SYNC_ERR;

	uint8_t len = frame[2];
	if(len + SYNC_LEN + LEN_LEN > size)
		return SECURE_UART_LEN_ERR;

	uint8_t *payload = &frame[4];
	uint8_t plen     = len - (CNT_LEN+CRC_LEN+MAC_LEN);
	uint8_t *crc_ptr = payload + plen;
	uint8_t *mac_ptr = crc_ptr + CRC_LEN;

	/* CRC */
//	uint8_t const payload_len  = frame[2];
	uint16_t crc_region = LEN_LEN + CNT_LEN + plen;
	uint32_t calc_crc = crc32(frame + SYNC_LEN, crc_region);
	uint32_t  recv_crc;      memcpy(&recv_crc, crc_ptr, 4);
	memcpy(&recv_crc, crc_ptr, 4);
	if (calc_crc != recv_crc) return SECURE_UART_CRC_ERR;

	/* MAC */
	uint64_t calc_mac = siphash24(frame+SYNC_LEN+LEN_LEN,
			plen + CNT_LEN + CRC_LEN);
	uint64_t recv_mac; memcpy(&recv_mac, mac_ptr, 8);
	if(calc_mac != recv_mac) return SECURE_UART_MAC_ERR;

	/* CNT / replay */
	uint8_t cnt_in = frame[3];
	uint8_t diff   = cnt_in - cnt_rx_last;
	if(diff == 0 || diff > SECURE_UART_CNT_WINDOW)
		return SECURE_UART_REPLAY_ERR;
	cnt_rx_last = cnt_in;

#if SECURE_UART_USE_ENCRYPTION
#if SECURE_UART_CIPHER == CIPHER_SPECK
	uint32_t rk[26];
	speck64_key_schedule(speck_k96, rk);
	speck64_ctr_crypt(rk, payload, plen, frame[3]);   /* iv = CNT */
#elif SECURE_UART_CIPHER == CIPHER_AES
    /* Initialize AES context if not done yet */
    static uint8_t aes_initialized = 0;
    if (!aes_initialized) {
        aes_init();
        aes_initialized = 1;
    }

    aes_ctr_crypt(&aes_context, payload, plen, frame[3]);   /* iv = CNT */
#endif

	memcpy(out, payload, plen);

#else
	memcpy(out, payload, plen);
#endif

	*out_len = plen;
	return SECURE_UART_OK;
}

/* helper for logs */
const char *secure_uart_status_str(secure_uart_status_t s)
{
	static const char *tbl[] = {"OK","SYNC","LEN","CRC","MAC","REPLAY"};
	return (s<=SECURE_UART_REPLAY_ERR)? tbl[s] : "?";
}

/* SPECK benchmark function */
uint32_t secure_uart_benchmark_speck(uint16_t iterations, uint16_t data_size) {
#if SECURE_UART_CIPHER == CIPHER_SPECK
    uint32_t rk[26];
    speck64_key_schedule(speck_k96, rk);

    uint8_t *data = (uint8_t*)malloc(data_size);
    if (data == NULL) {
        return 0; // Memory allocation failed
    }

    /* Initialize test data */
    for (uint16_t i = 0; i < data_size; i++) {
        data[i] = (uint8_t)i;
    }

    /* Benchmark timing */
    uint32_t start_time = HAL_GetTick();

    for (uint16_t i = 0; i < iterations; i++) {
        speck64_ctr_crypt(rk, data, data_size, i);
    }

    uint32_t end_time = HAL_GetTick();
    free(data);

    return end_time - start_time;
#else
    return 0; // SPECK not configured
#endif
}

/* AES benchmark function (delegates to secure_aes.c if available) */
uint32_t secure_uart_benchmark_aes(uint16_t iterations, uint16_t data_size) {
#if SECURE_UART_CIPHER == CIPHER_AES
    return aes_benchmark(iterations, data_size);
#else
    return 0; // AES not configured
#endif
}

/* Run comparison benchmark between SPECK and AES */
void secure_uart_run_comparison(void) {
    const uint16_t iterations = 1000;
    const uint16_t data_sizes[] = {16, 64, 128, 256};
    const uint8_t num_sizes = sizeof(data_sizes) / sizeof(data_sizes[0]);

    printf("Secure UART Cipher Performance Comparison\r\n");
    printf("=========================================\r\n");
    printf("Running %u iterations for each test\r\n\r\n", iterations);

    printf("Data Size | SPECK (ms) | SPECK KB/s | AES (ms) | AES KB/s | Ratio\r\n");
    printf("---------------------------------------------------------------\r\n");

    for (uint8_t i = 0; i < num_sizes; i++) {
        uint16_t size = data_sizes[i];

        uint32_t speck_time = secure_uart_benchmark_speck(iterations, size);
        uint32_t aes_time = secure_uart_benchmark_aes(iterations, size);

        float speck_throughput = (speck_time > 0) ?
            ((float)size * iterations) / speck_time : 0;
        float aes_throughput = (aes_time > 0) ?
            ((float)size * iterations) / aes_time : 0;

        float ratio = (aes_time > 0 && speck_time > 0) ?
            (float)aes_time / speck_time : 0;

        printf("%5u B   | %10lu | %10.2f | %8lu | %8.2f | %.2f\r\n",
               size, speck_time, speck_throughput, aes_time, aes_throughput, ratio);
    }

    printf("\r\nNote: Higher ratio means AES is slower compared to SPECK\r\n");
}
